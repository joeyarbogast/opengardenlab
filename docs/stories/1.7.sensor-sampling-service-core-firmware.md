# Story 1.7: Sensor Sampling Service (Core Firmware Loop)

## Status
Draft

## Story
**As a** developer,
**I want** a Python service that reads all sensors every N minutes and stores readings in SQLite,
**so that** the device continuously monitors garden conditions without manual intervention.

## Acceptance Criteria
1. Sensor sampling service implemented in `firmware/sensor_service.py` as a continuous loop:
   - Read all sensors (STEMMA Soil, BH1750, DHT20, DS18B20)
   - Insert reading into SQLite database with current timestamp
   - Sleep for configurable interval (default: 15 minutes)
   - Handle sensor read errors gracefully (log error, skip reading, continue loop)
2. Configuration file `firmware/config.yaml` with settings:
   - `sampling_interval_minutes` (default: 15)
   - `soil_moisture_calibration` (air_value, water_value - defaults for uncalibrated)
3. Sensor readings are calibrated for soil moisture (convert raw STEMMA value â†’ 0-100% using config values)
4. Service runs in foreground initially (prints log messages to console for debugging)
5. Service tested for 1 hour: readings captured every 15 minutes, stored in database, no crashes

## Tasks / Subtasks

**ðŸ¤– AI AGENT CAN EXECUTE (via SSH to Raspberry Pi):**

- [ ] Create configuration file and config loader module (AC: 2)
  - [ ] SSH into Raspberry Pi
  - [ ] Create config file: `nano ~/opengardenlab/firmware/config.yaml`
  - [ ] Write configuration structure:
    ```yaml
    device_id: "opengardenlab-rpi001"  # Unique device identifier
    sampling_interval_minutes: 15      # Sampling frequency (15, 30, or 60)
    soil_moisture_calibration:
      air_value: 200                   # Raw reading in air (0% moisture)
      water_value: 2000                # Raw reading in water (100% moisture)
    ```
  - [ ] Save and exit nano (Ctrl+X, Y, Enter)
  - [ ] Create config loader module: `nano ~/opengardenlab/firmware/config.py`
  - [ ] Implement config module:
    ```python
    import yaml
    from typing import Dict

    def load_config(config_path: str = "firmware/config.yaml") -> Dict:
        """Load YAML configuration file"""
        with open(config_path, 'r') as f:
            config = yaml.safe_load(f)
        return config

    def save_config(config: Dict, config_path: str = "firmware/config.yaml"):
        """Save configuration to YAML (for Bluetooth config updates)"""
        with open(config_path, 'w') as f:
            yaml.dump(config, f, default_flow_style=False)
    ```
  - [ ] Install PyYAML library: `pip3 install PyYAML`
  - [ ] Verify PyYAML installation: `pip3 list | grep PyYAML`

- [ ] Create sensor drivers directory and modules (AC: 1)
  - [ ] Create sensors directory: `mkdir -p ~/opengardenlab/firmware/sensors`
  - [ ] Create __init__.py: `touch ~/opengardenlab/firmware/sensors/__init__.py`
  - [ ] Create STEMMA Soil sensor driver: `nano ~/opengardenlab/firmware/sensors/stemma_soil.py`
  - [ ] Implement STEMMASoilSensor class with:
    - [ ] `__init__(i2c_bus, address=0x36)`
    - [ ] `read_moisture_raw() -> int` (returns raw capacitance value)
    - [ ] `read_temperature() -> float` (returns soil temp in Â°C)
    - [ ] `calibrate_moisture(raw_value, air_value, water_value) -> float` (converts to 0-100%)
  - [ ] Create BH1750 light sensor driver: `nano ~/opengardenlab/firmware/sensors/bh1750_light.py`
  - [ ] Implement BH1750LightSensor class with:
    - [ ] `__init__(i2c_bus, address=0x23)`
    - [ ] `read_lux() -> float` (returns light intensity in lux)
  - [ ] Create DHT20 sensor driver: `nano ~/opengardenlab/firmware/sensors/dht20_temp_humid.py`
  - [ ] Implement DHT20Sensor class with:
    - [ ] `__init__(i2c_bus, address=0x38)`
    - [ ] `read_temperature() -> float` (returns air temp in Â°C)
    - [ ] `read_humidity() -> float` (returns RH 0-100%)
  - [ ] Create DS18B20 sensor driver: `nano ~/opengardenlab/firmware/sensors/ds18b20_temp.py`
  - [ ] Implement DS18B20Sensor class with:
    - [ ] `__init__()` (auto-detects 1-Wire sensor)
    - [ ] `read_temperature() -> Optional[float]` (returns soil temp or None if sensor missing)

- [ ] Implement sensor sampling service (AC: 1, 3, 4)
  - [ ] Create service file: `nano ~/opengardenlab/firmware/sensor_service.py`
  - [ ] Implement SensorSamplingService class:
    - [ ] Load configuration from config.yaml
    - [ ] Initialize I2C bus and all sensor drivers
    - [ ] Initialize SensorDataStore (from Story 1.6)
    - [ ] Configure logging to console (basic logging setup)
    - [ ] Implement `read_all_sensors()` method:
      - [ ] Read raw moisture from STEMMA
      - [ ] Load calibration values from config
      - [ ] Apply calibration: convert raw moisture â†’ 0-100%
      - [ ] Read all other sensors (soil temp, light, air temp/humidity)
      - [ ] Return dictionary with all readings
      - [ ] Handle sensor read errors gracefully (try/except, log error, return None)
    - [ ] Implement `run()` main loop:
      - [ ] Log service startup with sampling interval
      - [ ] Infinite while loop:
        - [ ] Call `read_all_sensors()`
        - [ ] If readings successful, insert into database via `storage.insert_reading()`
        - [ ] Log reading stored confirmation
        - [ ] Sleep for sampling_interval_minutes Ã— 60 seconds
        - [ ] Continue loop (errors don't crash service)
  - [ ] Add `if __name__ == "__main__":` entry point to run service
  - [ ] Save and exit nano (Ctrl+X, Y, Enter)

- [ ] Test sensor sampling service (AC: 5)
  - [ ] Run service in foreground: `python3 ~/opengardenlab/firmware/sensor_service.py`
  - [ ] Verify startup log message shows sampling interval
  - [ ] Wait for first sensor reading cycle (15 minutes default)
  - [ ] Verify console output shows:
    - [ ] Sensor readings logged (moisture %, temps, lux, humidity)
    - [ ] Calibrated soil moisture percentage (0-100%)
    - [ ] "Reading stored to database" confirmation
  - [ ] Let service run for 1 hour (4 sampling cycles at 15-min intervals)
  - [ ] Monitor console for errors (no crashes, service continues after errors)
  - [ ] Stop service: Ctrl+C
  - [ ] Query database to verify readings stored:
    ```bash
    sqlite3 ~/opengardenlab/firmware/data/sensor_data.db "SELECT COUNT(*) FROM sensor_readings"
    ```
  - [ ] Expected: At least 4 readings (1 hour Ã· 15 min/reading)
  - [ ] Query latest reading to verify data:
    ```bash
    sqlite3 ~/opengardenlab/firmware/data/sensor_data.db "SELECT * FROM sensor_readings ORDER BY timestamp DESC LIMIT 1"
    ```
  - [ ] Verify all sensor values present (moisture, temps, lux, humidity)
  - [ ] Document test results for story completion

- [ ] Test error handling and service resilience (AC: 1)
  - [ ] Simulate sensor error: Temporarily disconnect one I2C sensor (e.g., unplug STEMMA)
  - [ ] Run service: `python3 ~/opengardenlab/firmware/sensor_service.py`
  - [ ] Verify service logs error but continues running (doesn't crash)
  - [ ] Reconnect sensor, verify service recovers on next cycle
  - [ ] Test with DS18B20 disconnected (optional sensor):
    - [ ] Verify `soil_temp_ds18b20` field is NULL in database
    - [ ] Verify service continues normally with other sensors
  - [ ] Document error handling behavior

## Dev Notes

### Sensor Sampling Service Architecture
**Service Purpose** [Source: architecture/firmware-architecture-raspberry-pi.md]
- **Core firmware loop:** Orchestrates sensor reading, calibration, and storage
- **Continuous operation:** Runs indefinitely, samples sensors at configured interval
- **Offline-first:** No network required, stores all data locally in SQLite
- **Autonomous:** Operates without user intervention after startup

**Service Location** [Source: architecture/repository-structure.md]
- **File path:** `firmware/sensor_service.py`
- **Entry point:** `if __name__ == "__main__":` for direct execution
- **Future:** Will become systemd service in Story 1.9 (autostart on boot)

### Configuration Management
**Config File Format** [Source: architecture/firmware-architecture-raspberry-pi.md, AC 2]
```yaml
device_id: "opengardenlab-rpi001"  # Unique identifier (MAC address or UUID)
sampling_interval_minutes: 15      # 15, 30, or 60 (MVP default: 15)
soil_moisture_calibration:
  air_value: 200                   # Raw reading in air (dry = 0% moisture)
  water_value: 2000                # Raw reading in water (wet = 100% moisture)
```

**Config Loader Module** [Source: architecture/firmware-architecture-raspberry-pi.md]
- **File path:** `firmware/config.py`
- **Library:** PyYAML 6.0+ [Source: architecture/tech-stack.md]
- **Functions:**
  - `load_config(config_path)` - Read YAML, return dict
  - `save_config(config, config_path)` - Write dict to YAML (for Bluetooth updates)

**Dual-Storage Configuration** [Source: architecture/firmware-architecture-raspberry-pi.md]
- **YAML file:** Human-editable via SSH, loaded at startup
- **SQLite device_config table:** Runtime config, updated by Bluetooth
- **Sync strategy:** On startup, YAML â†’ SQLite. Bluetooth updates both YAML and SQLite.

### Sensor Driver Modules
**Driver Architecture** [Source: architecture/firmware-architecture-raspberry-pi.md]
- **Purpose:** Abstract I2C/1-Wire communication, provide simple read methods
- **Location:** `firmware/sensors/` directory
- **Shared I2C bus:** All I2C sensors (STEMMA, BH1750, DHT20) use same `board.I2C()` instance

**1. STEMMASoilSensor (stemma_soil.py)** [Source: architecture/firmware-architecture-raspberry-pi.md]
```python
from adafruit_seesaw.seesaw import Seesaw
from board import I2C

class STEMMASoilSensor:
    def __init__(self, i2c_bus: I2C, address: int = 0x36):
        self.sensor = Seesaw(i2c_bus, addr=address)

    def read_moisture_raw(self) -> int:
        """Returns raw capacitance (200-2000 typical)"""
        return self.sensor.moisture_read()

    def read_temperature(self) -> float:
        """Returns soil temp (Â°C)"""
        return self.sensor.get_temp()

    def calibrate_moisture(self, raw_value: int, air_value: int, water_value: int) -> float:
        """Converts raw â†’ 0-100% using calibration"""
        if water_value == air_value:
            return 0.0
        percentage = ((raw_value - air_value) / (water_value - air_value)) * 100
        return max(0.0, min(100.0, percentage))  # Clamp to 0-100%
```

**2. BH1750LightSensor (bh1750_light.py)** [Source: architecture/firmware-architecture-raspberry-pi.md]
```python
from adafruit_bh1750 import BH1750
from board import I2C

class BH1750LightSensor:
    def __init__(self, i2c_bus: I2C, address: int = 0x23):
        self.sensor = BH1750(i2c_bus, address)

    def read_lux(self) -> float:
        """Returns light intensity (0-65535 lux)"""
        return self.sensor.lux
```

**3. DHT20Sensor (dht20_temp_humid.py)** [Source: architecture/firmware-architecture-raspberry-pi.md]
```python
from adafruit_ahtx0 import AHTx0
from board import I2C

class DHT20Sensor:
    def __init__(self, i2c_bus: I2C, address: int = 0x38):
        self.sensor = AHTx0(i2c_bus, address)

    def read_temperature(self) -> float:
        """Returns air temp (Â°C)"""
        return self.sensor.temperature

    def read_humidity(self) -> float:
        """Returns relative humidity (0-100%)"""
        return self.sensor.relative_humidity
```

**4. DS18B20Sensor (ds18b20_temp.py)** [Source: architecture/firmware-architecture-raspberry-pi.md]
```python
from w1thermsensor import W1ThermSensor, Sensor

class DS18B20Sensor:
    def __init__(self):
        try:
            self.sensor = W1ThermSensor(sensor_type=Sensor.DS18B20)
        except Exception:
            self.sensor = None  # Optional sensor, may not be connected

    def read_temperature(self) -> float | None:
        """Returns soil temp (Â°C) or None if sensor missing"""
        if self.sensor is None:
            return None
        return self.sensor.get_temperature()
```

### Sensor Sampling Service Implementation
**Service Class Structure** [Source: architecture/firmware-architecture-raspberry-pi.md]
```python
import time
import logging
from board import I2C
from sensors.stemma_soil import STEMMASoilSensor
from sensors.bh1750_light import BH1750LightSensor
from sensors.dht20_temp_humid import DHT20Sensor
from sensors.ds18b20_temp import DS18B20Sensor
from storage import SensorDataStore
from config import load_config

class SensorSamplingService:
    def __init__(self):
        # Load configuration
        self.config = load_config("firmware/config.yaml")
        self.device_id = self.config['device_id']
        self.sampling_interval = self.config['sampling_interval_minutes'] * 60  # Convert to seconds

        # Initialize I2C bus (shared by all I2C sensors)
        i2c = I2C()

        # Initialize sensors
        self.stemma = STEMMASoilSensor(i2c)
        self.bh1750 = BH1750LightSensor(i2c)
        self.dht20 = DHT20Sensor(i2c)
        self.ds18b20 = DS18B20Sensor()  # 1-Wire, separate from I2C

        # Initialize storage
        self.storage = SensorDataStore()

        # Configure logging (Story 1.8 will enhance with file logging)
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger(__name__)

    def read_all_sensors(self) -> dict | None:
        """Read all sensors and apply calibration"""
        try:
            # Read raw soil moisture
            moisture_raw = self.stemma.read_moisture_raw()

            # Apply calibration from config
            soil_moisture = self.stemma.calibrate_moisture(
                moisture_raw,
                self.config['soil_moisture_calibration']['air_value'],
                self.config['soil_moisture_calibration']['water_value']
            )

            # Read all other sensors
            readings = {
                'soil_moisture': soil_moisture,
                'soil_temp_stemma': self.stemma.read_temperature(),
                'soil_temp_ds18b20': self.ds18b20.read_temperature(),  # May be None
                'light_lux': self.bh1750.read_lux(),
                'air_temp': self.dht20.read_temperature(),
                'air_humidity': self.dht20.read_humidity()
            }

            self.logger.info(f"Sensor readings: {readings}")
            return readings

        except Exception as e:
            self.logger.error(f"Sensor read error: {e}")
            return None  # Continue loop, don't crash

    def run(self):
        """Main loop: sample sensors every N minutes"""
        self.logger.info(f"Sensor service started (interval: {self.sampling_interval}s)")

        while True:
            readings = self.read_all_sensors()

            if readings:
                self.storage.insert_reading(
                    device_id=self.device_id,
                    soil_moisture=readings['soil_moisture'],
                    soil_temp_stemma=readings['soil_temp_stemma'],
                    soil_temp_ds18b20=readings['soil_temp_ds18b20'],
                    light_lux=readings['light_lux'],
                    air_temp=readings['air_temp'],
                    air_humidity=readings['air_humidity']
                )
                self.logger.info("Reading stored to database")

            time.sleep(self.sampling_interval)

if __name__ == "__main__":
    service = SensorSamplingService()
    service.run()
```

### Soil Moisture Calibration
**Why Calibration Needed** [Source: architecture/firmware-architecture-raspberry-pi.md]
- **Capacitive sensor variability:** Raw values vary by sensor unit, soil type, temperature
- **Uncalibrated range:** STEMMA raw values typically 200-2000 (arbitrary capacitance units)
- **User-friendly output:** Convert to 0-100% for intuitive understanding

**Calibration Process** (Story 1.7 uses default values, user calibration in Epic 3)
1. **Air reading (0% moisture):** Insert sensor in air, record raw value (~200)
2. **Water reading (100% moisture):** Submerge sensor in water, record raw value (~2000)
3. **Linear conversion:** `percentage = (raw - air) / (water - air) Ã— 100`
4. **Clamping:** Ensure output is 0-100% (handle readings outside calibration range)

**Default Calibration Values** [Source: AC 2]
- `air_value: 200` (typical dry air reading)
- `water_value: 2000` (typical submerged reading)
- **Note:** These are estimates. User should calibrate their specific sensor for accuracy (Epic 3)

### Error Handling and Service Resilience
**Graceful Degradation** [Source: AC 1]
- **Sensor read failures:** Log error, return None, skip reading, continue loop
- **Don't crash on errors:** One bad sensor reading shouldn't stop service
- **Optional sensors:** DS18B20 may be missing (returns None), service continues

**Error Handling Pattern** [Source: architecture/coding-standards.md]
```python
try:
    readings = read_all_sensors()
except Exception as e:
    logger.error(f"Error: {e}")
    return None  # Continue loop, don't crash
```

**Logging Levels** (Story 1.8 will enhance logging)
- **INFO:** Successful sensor readings, database inserts
- **WARNING:** Sensor read retries (future enhancement)
- **ERROR:** Sensor failures, database errors

### Testing Strategy
**1-Hour Integration Test** [Source: AC 5]
- **Duration:** 1 hour continuous operation
- **Expected cycles:** 4 readings (1 hour Ã· 15 min/reading)
- **Verification:**
  1. Service starts without errors
  2. Console logs show sensor readings every 15 minutes
  3. Calibrated soil moisture displayed (0-100%)
  4. Database query confirms 4+ readings stored
  5. No crashes or exceptions during 1-hour run

**Error Resilience Test** [Source: AC 1]
- **Simulate failures:** Disconnect sensors during operation
- **Expected behavior:**
  - Service logs error
  - Service continues running (doesn't crash)
  - Next cycle attempts sensor read again
  - If sensor reconnected, service recovers automatically

### Dependency on Previous Stories
- **Story 1.2 (Pi Setup):** SSH access, Python 3.9+ required
- **Story 1.3 (I2C/1-Wire):** Interfaces enabled, i2c-tools installed
- **Story 1.4 (I2C Sensors):** Adafruit libraries installed (seesaw, bh1750, ahtx0)
- **Story 1.5 (DS18B20):** w1thermsensor library installed, 1-Wire configured
- **Story 1.6 (Storage):** SensorDataStore module and SQLite database created
- **Next Story:** Story 1.8 will add file logging and health check indicator

### Expected Output (Console Logs)
**Service Startup:**
```
2025-10-03 10:00:00 - INFO - Sensor service started (interval: 900s)
```

**Sensor Reading Cycle:**
```
2025-10-03 10:00:05 - INFO - Sensor readings: {'soil_moisture': 45.2, 'soil_temp_stemma': 22.1, 'soil_temp_ds18b20': 21.8, 'light_lux': 12000.0, 'air_temp': 23.5, 'air_humidity': 55.2}
2025-10-03 10:00:06 - INFO - Reading stored to database
```

**Error Handling Example:**
```
2025-10-03 10:15:05 - ERROR - Sensor read error: [Errno 121] Remote I/O error
2025-10-03 10:30:05 - INFO - Sensor readings: {'soil_moisture': 46.1, ...}
```

### Testing
**Testing Standards for Story 1.7:**
- **Test Type:** Integration test (full service with real hardware sensors)
- **Test Duration:** 1 hour continuous operation (4 sampling cycles)
- **Verification Steps:**
  1. âœ… Configuration file created with correct YAML structure
  2. âœ… PyYAML library installed
  3. âœ… All sensor driver modules created (STEMMA, BH1750, DHT20, DS18B20)
  4. âœ… SensorSamplingService class implemented with all required methods
  5. âœ… Service starts successfully, logs startup message
  6. âœ… Sensor readings occur every 15 minutes
  7. âœ… Soil moisture calibration applied (raw value â†’ 0-100%)
  8. âœ… All sensor values logged to console (moisture %, temps, lux, humidity)
  9. âœ… Readings stored to SQLite database (verify with SQL query)
  10. âœ… Service runs for 1 hour without crashes (4+ readings captured)
  11. âœ… Error handling tested (sensor disconnect, service continues)
  12. âœ… DS18B20 optional sensor handling (NULL in database if disconnected)
- **Success Criteria:** Service runs autonomously for 1+ hour, captures sensor data every 15 min, handles errors gracefully
- **No automated unit tests:** Manual integration test (pytest unit tests added in Story 1.10)
[Source: architecture/testing-strategy.md - adapted for firmware integration story]

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-03 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*To be filled by QA agent*
