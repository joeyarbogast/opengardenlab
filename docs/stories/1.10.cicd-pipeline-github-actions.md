# Story 1.10: CI/CD Pipeline Setup with GitHub Actions

## Status
Draft

## Story
**As a** developer,
**I want** automated testing and build pipelines using GitHub Actions,
**so that** I can catch bugs early, ensure code quality, and automate builds for firmware and mobile app.

## Acceptance Criteria
1. GitHub Actions workflow file created: `.github/workflows/ci.yml`
2. Firmware testing pipeline configured:
   - Install Python dependencies (requirements.txt)
   - Run pytest for all firmware unit tests
   - Run Python linter (flake8 or pylint)
   - Execute on every pull request and push to main branch
3. Mobile app build pipeline configured:
   - Build Android APK (debug variant)
   - Run unit tests (JUnit for Kotlin or NUnit for .NET MAUI)
   - Run lint checks (Android Lint)
   - Execute on every pull request and push to main branch
4. Test framework dependencies added:
   - `pytest` added to `firmware/requirements.txt`
   - JUnit/Espresso (Kotlin) or NUnit (.NET MAUI) configured in mobile app
5. CI status badge added to README.md showing build status
6. First CI run completes successfully (all tests pass)

## Tasks / Subtasks

**ðŸ¤– AI AGENT CAN EXECUTE (via local development machine or SSH to repo):**

- [ ] Add pytest to firmware dependencies (AC: 4)
  - [ ] Navigate to repository root
  - [ ] Edit firmware requirements: `nano firmware/requirements.txt`
  - [ ] Add pytest and testing dependencies:
    ```
    # Sensor libraries
    adafruit-circuitpython-seesaw
    adafruit-circuitpython-bh1750
    adafruit-circuitpython-ahtx0
    w1thermsensor
    bleak
    PyYAML

    # Testing dependencies
    pytest>=7.4.0
    pytest-cov>=4.1.0
    flake8>=6.1.0
    ```
  - [ ] Save and commit changes

- [ ] Create sample pytest unit tests for firmware (AC: 2)
  - [ ] Create pytest config: `nano firmware/pytest.ini`
  - [ ] Write pytest configuration:
    ```ini
    [pytest]
    testpaths = tests
    python_files = test_*.py
    python_classes = Test*
    python_functions = test_*
    addopts = -v --strict-markers
    ```
  - [ ] Ensure firmware/tests/ has `__init__.py`: `touch firmware/tests/__init__.py`
  - [ ] Create sample unit test: `nano firmware/tests/test_calibration.py`
  - [ ] Write calibration test (doesn't require hardware):
    ```python
    import pytest

    def calibrate_moisture(raw_value: int, air_value: int, water_value: int) -> float:
        """Converts raw sensor reading to 0-100% using calibration values"""
        if water_value == air_value:
            return 0.0
        percentage = ((raw_value - air_value) / (water_value - air_value)) * 100
        return max(0.0, min(100.0, percentage))

    def test_calibrate_moisture_mid_range():
        """Test calibration with value in middle of range"""
        result = calibrate_moisture(500, 200, 2000)
        assert 16.0 <= result <= 17.0  # (500-200)/(2000-200) * 100 = 16.67%

    def test_calibrate_moisture_clamp_low():
        """Test clamping below air_value to 0%"""
        result = calibrate_moisture(100, 200, 2000)
        assert result == 0.0

    def test_calibrate_moisture_clamp_high():
        """Test clamping above water_value to 100%"""
        result = calibrate_moisture(2500, 200, 2000)
        assert result == 100.0

    def test_calibrate_moisture_zero_division():
        """Test handling of identical air/water values"""
        result = calibrate_moisture(500, 200, 200)
        assert result == 0.0
    ```
  - [ ] Save tests

- [ ] Create GitHub Actions workflow for firmware (AC: 1, 2)
  - [ ] Create workflows directory: `mkdir -p .github/workflows`
  - [ ] Create firmware CI workflow: `nano .github/workflows/firmware-ci.yml`
  - [ ] Write firmware pipeline:
    ```yaml
    name: Firmware CI

    on:
      push:
        branches: [ main ]
      pull_request:
        branches: [ main ]

    jobs:
      test:
        runs-on: ubuntu-latest

        steps:
        - name: Checkout code
          uses: actions/checkout@v3

        - name: Set up Python 3.9
          uses: actions/setup-python@v4
          with:
            python-version: '3.9'

        - name: Install dependencies
          run: |
            python -m pip install --upgrade pip
            pip install -r firmware/requirements.txt

        - name: Run flake8 linter
          run: |
            cd firmware
            flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
            flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

        - name: Run pytest
          run: |
            cd firmware
            pytest tests/ --cov=. --cov-report=term-missing
    ```
  - [ ] Save workflow file

- [ ] Create GitHub Actions workflow for mobile app (AC: 3) - OPTIONAL FOR MVP
  - [ ] Create mobile app CI workflow: `nano .github/workflows/mobile-ci.yml`
  - [ ] Write Android build pipeline (Kotlin):
    ```yaml
    name: Mobile App CI

    on:
      push:
        branches: [ main ]
      pull_request:
        branches: [ main ]

    jobs:
      build:
        runs-on: ubuntu-latest

        steps:
        - name: Checkout code
          uses: actions/checkout@v3

        - name: Set up JDK 17
          uses: actions/setup-java@v3
          with:
            java-version: '17'
            distribution: 'temurin'

        - name: Grant execute permission for gradlew
          run: chmod +x mobile-app/gradlew

        - name: Build with Gradle
          run: |
            cd mobile-app
            ./gradlew assembleDebug

        - name: Run unit tests
          run: |
            cd mobile-app
            ./gradlew test

        - name: Run Android Lint
          run: |
            cd mobile-app
            ./gradlew lint
    ```
  - [ ] Save workflow file
  - [ ] **Note:** This workflow will fail until mobile app is created (Epic 2)

- [ ] Add CI status badge to README (AC: 5)
  - [ ] Edit root README: `nano README.md`
  - [ ] Add badges section at top (after title):
    ```markdown
    # OpenGardenLab

    [![Firmware CI](https://github.com/YOURUSERNAME/opengardenlab/actions/workflows/firmware-ci.yml/badge.svg)](https://github.com/YOURUSERNAME/opengardenlab/actions/workflows/firmware-ci.yml)
    [![Mobile App CI](https://github.com/YOURUSERNAME/opengardenlab/actions/workflows/mobile-ci.yml/badge.svg)](https://github.com/YOURUSERNAME/opengardenlab/actions/workflows/mobile-ci.yml)

    **IoT garden monitoring system using Raspberry Pi + Android app**
    ```
  - [ ] Replace `YOURUSERNAME` with actual GitHub username
  - [ ] Save README

- [ ] Commit and push CI configuration (AC: 6)
  - [ ] Stage all CI files:
    ```bash
    git add .github/workflows/firmware-ci.yml
    git add .github/workflows/mobile-ci.yml
    git add firmware/requirements.txt
    git add firmware/pytest.ini
    git add firmware/tests/test_calibration.py
    git add README.md
    ```
  - [ ] Commit changes:
    ```bash
    git commit -m "Add CI/CD pipeline with GitHub Actions

    - Add firmware testing pipeline (pytest + flake8)
    - Add mobile app build pipeline (Gradle + JUnit)
    - Add pytest dependencies to requirements.txt
    - Add sample calibration unit tests
    - Add CI status badges to README"
    ```
  - [ ] Push to GitHub:
    ```bash
    git push origin main
    ```

- [ ] Verify GitHub Actions run (AC: 6)
  - [ ] Navigate to GitHub repository in browser
  - [ ] Go to "Actions" tab
  - [ ] Verify "Firmware CI" workflow triggered by push
  - [ ] Wait for workflow to complete
  - [ ] Check workflow status:
    - [ ] âœ… Checkout code step passed
    - [ ] âœ… Set up Python step passed
    - [ ] âœ… Install dependencies step passed
    - [ ] âœ… Run flake8 linter step passed (or shows warnings, not errors)
    - [ ] âœ… Run pytest step passed (all tests green)
  - [ ] If firmware CI fails:
    - [ ] Click into failed step to see error details
    - [ ] Fix issues locally, commit, push again
    - [ ] Repeat until CI passes
  - [ ] Verify mobile CI workflow:
    - [ ] May fail if mobile app not yet created (expected for Story 1.10)
    - [ ] Document status: "Mobile CI will pass after Epic 2 mobile app creation"

- [ ] Test pull request CI trigger
  - [ ] Create test branch: `git checkout -b test-ci`
  - [ ] Make trivial change: `echo "# CI Test" >> firmware/README.md`
  - [ ] Commit and push:
    ```bash
    git add firmware/README.md
    git commit -m "Test CI on pull request"
    git push origin test-ci
    ```
  - [ ] Create pull request on GitHub
  - [ ] Verify CI runs automatically on PR
  - [ ] Verify CI status appears in PR (green checkmark or red X)
  - [ ] Merge or close PR after testing
  - [ ] Delete test branch: `git branch -d test-ci`
  - [ ] Document PR CI trigger verified

## Dev Notes

### GitHub Actions Overview
**What is GitHub Actions?** [Source: architecture/tech-stack.md]
- **CI/CD Platform:** GitHub's built-in continuous integration and deployment service
- **Free for open-source:** Unlimited minutes for public repositories
- **YAML-based:** Workflows defined in `.github/workflows/*.yml` files
- **Event-driven:** Trigger on push, pull request, release, schedule, etc.

**Why GitHub Actions?** [Source: architecture/tech-stack.md]
- **Native integration:** No third-party service setup (Travis CI, CircleCI)
- **Free for this project:** Public repo = unlimited CI minutes
- **Simple configuration:** YAML workflows, no complex setup
- **Matrix builds:** Test multiple Python/Java versions simultaneously

### Workflow File Anatomy
**Location:** `.github/workflows/firmware-ci.yml` [Source: AC 1]

**Workflow Triggers:**
```yaml
on:
  push:
    branches: [ main ]        # Run on every push to main
  pull_request:
    branches: [ main ]        # Run on every PR targeting main
```

**Job Configuration:**
```yaml
jobs:
  test:
    runs-on: ubuntu-latest    # Use GitHub-hosted Ubuntu runner
```

**Steps:**
1. **Checkout code:** Clone repository to runner
2. **Set up Python:** Install Python 3.9
3. **Install dependencies:** `pip install -r firmware/requirements.txt`
4. **Run linter:** `flake8` checks code quality
5. **Run tests:** `pytest` executes unit tests

### pytest Configuration
**Why pytest?** [Source: AC 4, architecture/tech-stack.md]
- **Standard Python testing framework:** Industry standard, well-documented
- **Simple syntax:** Tests are just functions starting with `test_`
- **Fixtures and mocking:** Easy to mock I2C sensors for unit tests
- **Coverage reporting:** `pytest-cov` shows test coverage percentage

**pytest.ini Configuration:**
```ini
[pytest]
testpaths = tests           # Look for tests in firmware/tests/
python_files = test_*.py    # Test files start with test_
python_classes = Test*      # Test classes start with Test
python_functions = test_*   # Test functions start with test_
```

**Running pytest locally:**
```bash
cd firmware
pytest tests/                          # Run all tests
pytest tests/test_calibration.py      # Run specific test file
pytest -v                              # Verbose output
pytest --cov=.                         # Run with coverage report
```

### flake8 Linting
**What is flake8?** [Source: AC 2]
- **Python linter:** Checks code style (PEP 8), syntax errors, code complexity
- **Catches bugs:** Finds unused imports, undefined variables, syntax errors
- **Configurable:** Can adjust line length, complexity limits

**flake8 in CI:**
```bash
# Critical errors only (fail build)
flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics

# All warnings (don't fail build, just report)
flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
```

**Common flake8 error codes:**
- `E9`: Syntax errors
- `F63`: Invalid print statement syntax
- `F7`: Syntax errors in type comments
- `F82`: Undefined name
- `W503`: Line break before binary operator (warning)

**Customizing flake8:**
Create `.flake8` in firmware/ directory:
```ini
[flake8]
max-line-length = 127
exclude = .git,__pycache__,venv
ignore = W503,E203
```

### Mobile App CI Pipeline (Kotlin/Android)
**Gradle Build System** [Source: AC 3, architecture/tech-stack.md]
- **Android build tool:** Compiles Kotlin code, builds APK
- **Tasks:**
  - `assembleDebug`: Build debug APK (unsigned, for testing)
  - `test`: Run JUnit unit tests
  - `lint`: Run Android Lint (code quality checks)

**GitHub Actions Android Setup:**
```yaml
- name: Set up JDK 17
  uses: actions/setup-java@v3
  with:
    java-version: '17'          # Android requires Java 17+
    distribution: 'temurin'     # Eclipse Temurin JDK

- name: Build with Gradle
  run: |
    cd mobile-app
    ./gradlew assembleDebug     # Build APK
```

**Note for Story 1.10:**
- Mobile app doesn't exist yet (created in Epic 2)
- Mobile CI workflow will fail until Epic 2
- This is expected and documented

### CI Status Badges
**Purpose** [Source: AC 5]
- **Visual status:** Show CI pass/fail status in README
- **Quick feedback:** Know if latest commit broke tests
- **Professional appearance:** Badges signal active development

**Badge Syntax:**
```markdown
[![Firmware CI](https://github.com/USER/REPO/actions/workflows/firmware-ci.yml/badge.svg)](https://github.com/USER/REPO/actions/workflows/firmware-ci.yml)
```

**Badge Colors:**
- ðŸŸ¢ Green: All tests passing
- ðŸ”´ Red: Tests failing
- ðŸŸ¡ Yellow: Workflow running

**Example Badges:**
- [![passing](https://img.shields.io/badge/build-passing-brightgreen)]() - All tests pass
- [![failing](https://img.shields.io/badge/build-failing-red)]() - Tests fail

### Testing Strategy for Firmware
**Unit Tests (pytest)** [Source: architecture/testing-strategy.md]
- **Mock hardware:** Use `unittest.mock.MagicMock` to simulate I2C sensors
- **Test logic, not hardware:** Calibration, storage, data processing
- **Fast execution:** No real sensor reads, tests run in seconds

**Example: Mocking I2C sensor:**
```python
from unittest.mock import MagicMock
from sensors.stemma_soil import STEMMASoilSensor

def test_read_moisture_raw():
    mock_i2c = MagicMock()
    sensor = STEMMASoilSensor(mock_i2c)

    # Mock sensor reading
    sensor.sensor.moisture_read = MagicMock(return_value=500)

    result = sensor.read_moisture_raw()
    assert result == 500
```

**What NOT to test in CI:**
- Real sensor hardware (I2C communication requires Raspberry Pi)
- Database persistence (use in-memory SQLite for tests)
- GPIO operations (mock RPi.GPIO library)

**Integration tests (manual):**
- Stories 1.4-1.7 hardware integration tests run on actual Raspberry Pi
- CI runs unit tests only (no hardware required)

### CI Workflow Triggers
**Push to main:** [Source: AC 2]
```yaml
on:
  push:
    branches: [ main ]
```
- Runs whenever code is merged to main branch
- Catches bugs in deployed code
- Ensures main branch always passes tests

**Pull Requests:** [Source: AC 2]
```yaml
on:
  pull_request:
    branches: [ main ]
```
- Runs before code is merged
- Prevents broken code from reaching main
- PR cannot merge if CI fails (configurable)

**Other triggers (future):**
- `on: schedule` - Run tests nightly (cron syntax)
- `on: release` - Build APK when creating GitHub release
- `on: workflow_dispatch` - Manual trigger from GitHub UI

### Free GitHub Actions Minutes
**Limits for Public Repos:** [Source: architecture/tech-stack.md]
- **Unlimited minutes** for public repositories
- **2,000 minutes/month** for private repos (free tier)
- **20 concurrent jobs** for free accounts

**Typical CI Duration:**
- Firmware CI: ~2-3 minutes (install deps, run tests, lint)
- Mobile CI: ~5-10 minutes (download Android SDK, build APK)

**This project's usage:**
- ~10 commits/day Ã— 3 min/run = 30 min/day
- 30 min/day Ã— 30 days = 900 min/month
- Well within free tier limits

### Dependency on Previous Stories
- **Story 1.6 (Storage):** Unit tests for storage module created
- **Story 1.7 (Sensor Service):** Calibration logic to test
- **Story 1.8 (Logging):** Can add logging unit tests (optional)
- **Next Story:** Story 1.11 firmware update procedure benefits from CI (test before deploy)

### CI Best Practices
**Fail Fast:**
- Run linter first (fastest, catches syntax errors)
- Then unit tests (medium speed)
- Finally integration tests (slowest, requires hardware)

**Test Isolation:**
- Each test should be independent (no shared state)
- Use in-memory databases (`:memory:`) for speed
- Mock external dependencies (sensors, network)

**Clear Error Messages:**
```python
def test_calibrate_moisture():
    result = calibrate_moisture(500, 200, 2000)
    assert 16 <= result <= 17, f"Expected 16-17%, got {result}%"
```

**Coverage Targets:**
- 70%+ for MVP (as specified in testing-strategy.md)
- Focus on critical logic (calibration, storage, protocol)
- Don't obsess over 100% (diminishing returns)

### Testing
**Testing Standards for Story 1.10:**
- **Test Type:** CI/CD pipeline integration test
- **Verification Steps:**
  1. âœ… GitHub Actions workflows created (`.github/workflows/firmware-ci.yml`)
  2. âœ… pytest added to `firmware/requirements.txt`
  3. âœ… Sample unit tests created (`test_calibration.py`)
  4. âœ… pytest.ini configuration file created
  5. âœ… flake8 linter configured in CI workflow
  6. âœ… Workflow triggers on push to main
  7. âœ… Workflow triggers on pull requests
  8. âœ… CI status badges added to README
  9. âœ… First CI run completes successfully (all tests pass)
  10. âœ… Pull request CI trigger tested
  11. âœ… Mobile app CI workflow created (will pass after Epic 2)
- **Success Criteria:** CI runs automatically, tests pass, badges show green
- **Note:** Mobile app CI will fail until Epic 2 (expected, documented)
[Source: architecture/testing-strategy.md]

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-03 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*To be filled by QA agent*
