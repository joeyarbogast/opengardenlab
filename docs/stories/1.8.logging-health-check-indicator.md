# Story 1.8: Logging and Health Check Indicator

## Status
Draft

## Story
**As a** developer,
**I want** structured logging and a visual health indicator (LED or console message),
**so that** I can monitor firmware status and troubleshoot issues during development.

## Acceptance Criteria
1. Python logging configured with rotating file handler: `firmware/logs/sensor_service.log`
2. Log levels used appropriately:
   - INFO: Successful sensor readings ("Read sensors: moisture=45%, lux=12000, temp=22Â°C")
   - WARNING: Sensor read errors ("Failed to read BH1750, retrying...")
   - ERROR: Critical failures ("Database connection failed")
3. Optional: GPIO LED blink every sampling cycle (LED on Pin 17, blinks for 1 second after each successful reading)
4. Logs rotate after 10MB, keep last 5 log files
5. SSH into Pi, tail logs in real-time (`tail -f firmware/logs/sensor_service.log`) to observe sampling

## Tasks / Subtasks

**ðŸ¤– AI AGENT CAN EXECUTE (via SSH to Raspberry Pi):**

- [ ] Configure rotating file logging in sensor_service.py (AC: 1, 2, 4)
  - [ ] SSH into Raspberry Pi
  - [ ] Create logs directory: `mkdir -p ~/opengardenlab/firmware/logs`
  - [ ] Edit sensor_service.py: `nano ~/opengardenlab/firmware/sensor_service.py`
  - [ ] Update logging configuration in `__init__()` method:
    - [ ] Import `RotatingFileHandler` from `logging.handlers`
    - [ ] Create log directory if it doesn't exist
    - [ ] Configure rotating file handler:
      - [ ] Log file path: `firmware/logs/sensor_service.log`
      - [ ] Max file size: 10MB (10 * 1024 * 1024 bytes)
      - [ ] Backup count: 5 (keeps 5 old log files)
    - [ ] Add console handler for debugging (StreamHandler to stdout)
    - [ ] Set log format: `%(asctime)s - %(name)s - %(levelname)s - %(message)s`
    - [ ] Set log level: INFO
  - [ ] Update `read_all_sensors()` method:
    - [ ] Add INFO log after successful reading: include key values (moisture %, lux, temps)
    - [ ] Change generic error logging to WARNING for sensor read failures
    - [ ] Add ERROR log for critical failures (database connection, config load errors)
  - [ ] Update `run()` method:
    - [ ] Add INFO log on service startup with config details
    - [ ] Add INFO log after successful database insert
    - [ ] Add WARNING log if reading was skipped due to sensor error
  - [ ] Save and exit nano (Ctrl+X, Y, Enter)

- [ ] Optional: Implement GPIO LED health indicator (AC: 3)
  - [ ] Edit sensor_service.py: `nano ~/opengardenlab/firmware/sensor_service.py`
  - [ ] Import GPIO library: `import RPi.GPIO as GPIO`
  - [ ] Add LED initialization in `__init__()`:
    - [ ] Set GPIO mode: `GPIO.setmode(GPIO.BCM)`
    - [ ] Set GPIO warnings off: `GPIO.setwarnings(False)`
    - [ ] Configure Pin 17 as output: `GPIO.setup(17, GPIO.OUT)`
    - [ ] Initialize LED off: `GPIO.output(17, GPIO.LOW)`
  - [ ] Create `blink_led()` method:
    ```python
    def blink_led(self):
        """Blink LED on Pin 17 for 1 second"""
        try:
            GPIO.output(17, GPIO.HIGH)
            time.sleep(1)
            GPIO.output(17, GPIO.LOW)
        except Exception as e:
            self.logger.warning(f"LED blink failed: {e}")
    ```
  - [ ] Call `blink_led()` in `run()` after successful reading stored
  - [ ] Add GPIO cleanup in service shutdown (future enhancement)
  - [ ] Save and exit nano (Ctrl+X, Y, Enter)
  - [ ] **[HUMAN]** Optional: Wire LED to GPIO Pin 17:
    - [ ] LED anode (long leg) â†’ Pin 17 (GPIO17) via 220Î© resistor
    - [ ] LED cathode (short leg) â†’ Pin 6 (GND)

- [ ] Test logging functionality (AC: 5)
  - [ ] Run sensor service: `python3 ~/opengardenlab/firmware/sensor_service.py`
  - [ ] Verify log file created: `ls -lh ~/opengardenlab/firmware/logs/`
  - [ ] Wait for first sensor reading cycle
  - [ ] Open second SSH session to tail logs in real-time:
    ```bash
    tail -f ~/opengardenlab/firmware/logs/sensor_service.log
    ```
  - [ ] Verify log output shows:
    - [ ] Service startup INFO message with sampling interval
    - [ ] Sensor reading INFO messages with values
    - [ ] Database insert INFO confirmation
    - [ ] Proper timestamp format on all log entries
  - [ ] Stop service (Ctrl+C)
  - [ ] Verify log file size: `ls -lh ~/opengardenlab/firmware/logs/sensor_service.log`
  - [ ] Restart service, verify logs continue appending (no overwrite)

- [ ] Test log rotation (AC: 4)
  - [ ] Create test script to generate large log file: `nano ~/opengardenlab/firmware/tests/test_log_rotation.py`
  - [ ] Write log rotation test:
    ```python
    #!/usr/bin/env python3
    import logging
    from logging.handlers import RotatingFileHandler
    import os

    # Create same logging config as sensor_service.py
    log_dir = os.path.expanduser("~/opengardenlab/firmware/logs")
    log_file = os.path.join(log_dir, "test_rotation.log")

    handler = RotatingFileHandler(
        log_file,
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5
    )
    handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))

    logger = logging.getLogger('test_rotation')
    logger.setLevel(logging.INFO)
    logger.addHandler(handler)

    # Generate ~12MB of logs to trigger rotation
    print("Generating logs to test rotation (this will take a minute)...")
    for i in range(150000):
        logger.info(f"Test log message {i}: " + "x" * 80)
        if i % 10000 == 0:
            print(f"Generated {i} log entries...")

    print("Done! Check log files:")
    os.system(f"ls -lh {log_dir}/test_rotation.log*")
    ```
  - [ ] Run test: `python3 ~/opengardenlab/firmware/tests/test_log_rotation.py`
  - [ ] Verify rotation occurred:
    - [ ] `test_rotation.log` exists (current log, <10MB)
    - [ ] `test_rotation.log.1` exists (first rotated backup)
    - [ ] Rotation triggered when log exceeded 10MB
  - [ ] Clean up test logs: `rm ~/opengardenlab/firmware/logs/test_rotation.log*`
  - [ ] Document rotation behavior verified

- [ ] Test log levels and error handling (AC: 2)
  - [ ] Simulate sensor error: Temporarily disconnect one I2C sensor
  - [ ] Run service: `python3 ~/opengardenlab/firmware/sensor_service.py`
  - [ ] Tail logs: `tail -f ~/opengardenlab/firmware/logs/sensor_service.log`
  - [ ] Verify WARNING-level log appears for sensor read failure
  - [ ] Verify service continues running (doesn't crash)
  - [ ] Reconnect sensor, verify INFO logs resume
  - [ ] Stop service
  - [ ] Review log file for proper log level usage:
    - [ ] INFO: Service startup, sensor readings, database inserts
    - [ ] WARNING: Sensor read errors
    - [ ] ERROR: Critical failures (if any occurred)
  - [ ] Document log level verification

## Dev Notes

### Python Logging Architecture
**Logging Purpose** [Source: architecture/tech-stack.md]
- **Debugging:** SSH-accessible logs for troubleshooting sensor issues, database errors
- **Monitoring:** Track firmware health during development and deployment
- **Audit trail:** Record sampling history, errors, configuration changes

**Logging Module** [Source: architecture/tech-stack.md]
- **Library:** Python `logging` module (built-in to Python 3.9+)
- **No installation needed:** Standard library, no pip dependencies
- **Features:**
  - Multiple handlers (file + console)
  - Log rotation (prevents disk space issues)
  - Configurable log levels (DEBUG, INFO, WARNING, ERROR, CRITICAL)
  - Thread-safe (safe for concurrent logging)

### RotatingFileHandler Configuration
**Purpose** [Source: AC 1, 4]
- **Prevents disk space exhaustion:** Automatically rotates logs when file size exceeds limit
- **Keeps historical logs:** Maintains 5 backup files for troubleshooting
- **Predictable storage:** Max storage = 10MB Ã— 6 files = 60MB (current + 5 backups)

**Configuration** [Source: architecture/firmware-architecture-raspberry-pi.md]
```python
from logging.handlers import RotatingFileHandler

handler = RotatingFileHandler(
    filename='firmware/logs/sensor_service.log',
    maxBytes=10*1024*1024,  # 10MB per file
    backupCount=5           # Keep 5 old log files
)
```

**Rotation Behavior:**
- When `sensor_service.log` reaches 10MB:
  1. Rename `sensor_service.log` â†’ `sensor_service.log.1`
  2. Rename `sensor_service.log.1` â†’ `sensor_service.log.2` (if exists)
  3. ... (cascade up to `.5`)
  4. Delete `sensor_service.log.5` (oldest backup)
  5. Create new empty `sensor_service.log`

**Storage Calculation:**
- 10MB Ã— 6 = 60MB max (current + 5 backups)
- 15-min sampling Ã— ~200 bytes/log = 96 logs/day Ã— 200 = 19.2 KB/day
- 60MB Ã· 19.2KB/day = ~3125 days (8.5+ years) of logs

### Log Levels and Usage
**Log Level Standards** [Source: AC 2, architecture/coding-standards.md]

**INFO - Normal Operations:**
```python
self.logger.info(f"Sensor service started (interval: {self.sampling_interval}s)")
self.logger.info(f"Sensor readings: moisture={moisture}%, lux={lux}, temp={temp}Â°C")
self.logger.info("Reading stored to database")
```

**WARNING - Recoverable Errors:**
```python
self.logger.warning(f"Failed to read BH1750: {e}, retrying next cycle")
self.logger.warning(f"DS18B20 sensor not detected, skipping soil temp reading")
```

**ERROR - Critical Failures:**
```python
self.logger.error(f"Database connection failed: {e}")
self.logger.error(f"Config file not found: {config_path}")
```

**Best Practices:**
- **INFO:** Expected events (startup, sensor reads, database inserts)
- **WARNING:** Unexpected but handled events (sensor errors, retries)
- **ERROR:** Unrecoverable errors that prevent functionality
- **Don't log at DEBUG level in production:** Too verbose, fills logs quickly

### Log Format
**Standard Format** [Source: architecture/firmware-architecture-raspberry-pi.md]
```python
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[file_handler, console_handler]
)
```

**Example Output:**
```
2025-10-03 10:00:00,123 - __main__ - INFO - Sensor service started (interval: 900s)
2025-10-03 10:00:05,456 - __main__ - INFO - Sensor readings: moisture=45.2%, lux=12000, temp=22.1Â°C
2025-10-03 10:00:06,789 - __main__ - INFO - Reading stored to database
```

**Components:**
- `%(asctime)s` - Timestamp (YYYY-MM-DD HH:MM:SS,milliseconds)
- `%(name)s` - Logger name (module name, e.g., `__main__`)
- `%(levelname)s` - Log level (INFO, WARNING, ERROR)
- `%(message)s` - Log message

### Dual Handlers: File + Console
**Multiple Handlers** [Source: architecture/firmware-architecture-raspberry-pi.md]
```python
file_handler = RotatingFileHandler('firmware/logs/sensor_service.log', maxBytes=10*1024*1024, backupCount=5)
console_handler = logging.StreamHandler()  # Outputs to stdout

logger.addHandler(file_handler)
logger.addHandler(console_handler)
```

**Why Both:**
- **File handler:** Persistent logs for debugging, SSH tail access
- **Console handler:** Real-time output when running in foreground (Story 1.7 testing)
- **Systemd integration (Story 1.9):** Console logs captured by journalctl

### GPIO LED Health Indicator (Optional)
**Purpose** [Source: AC 3]
- **Visual feedback:** LED blinks after each successful sensor reading
- **Debugging aid:** Confirms service is running without SSH access
- **Optional:** Not required for MVP, but helpful for field deployments

**GPIO Configuration** [Source: architecture/hardware-architecture.md]
- **Pin:** GPIO17 (Physical Pin 11, BCM numbering)
- **Wiring:**
  - LED anode (long leg) â†’ GPIO17 via 220Î© resistor
  - LED cathode (short leg) â†’ GND (Pin 6)
- **Resistor:** 220Î©-330Î© limits current to ~10-15mA (safe for Pi GPIO)

**RPi.GPIO Library:**
```python
import RPi.GPIO as GPIO

GPIO.setmode(GPIO.BCM)       # Use BCM pin numbering
GPIO.setwarnings(False)      # Suppress warnings
GPIO.setup(17, GPIO.OUT)     # Configure Pin 17 as output
GPIO.output(17, GPIO.HIGH)   # Turn LED on
GPIO.output(17, GPIO.LOW)    # Turn LED off
```

**Blink Pattern:**
- **On:** 1 second after successful sensor reading
- **Off:** Immediately after (during sleep interval)
- **Frequency:** Once per sampling cycle (every 15 minutes)

**Error Handling:**
- LED blink failures logged as WARNING (don't crash service)
- Service continues if GPIO not available (headless operation)

### Real-Time Log Monitoring
**SSH Tail Access** [Source: AC 5]
```bash
# Real-time log monitoring (shows new lines as they're written)
tail -f ~/opengardenlab/firmware/logs/sensor_service.log

# Show last 50 lines
tail -n 50 ~/opengardenlab/firmware/logs/sensor_service.log

# Search logs for errors
grep ERROR ~/opengardenlab/firmware/logs/sensor_service.log

# Follow logs with grep filter (only show errors)
tail -f ~/opengardenlab/firmware/logs/sensor_service.log | grep ERROR
```

**Debugging Workflow:**
1. SSH into Raspberry Pi
2. Start service in one terminal: `python3 ~/opengardenlab/firmware/sensor_service.py`
3. Open second SSH session, tail logs: `tail -f firmware/logs/sensor_service.log`
4. Observe sensor readings, errors in real-time
5. Stop service (Ctrl+C), review logs for issues

### Dependency on Previous Stories
- **Story 1.2 (Pi Setup):** SSH access required for log monitoring
- **Story 1.7 (Sensor Service):** Logging integrated into existing sensor_service.py
- **Next Story:** Story 1.9 will configure systemd to capture logs via journalctl

### Expected Log Output (Full Day)
**Startup:**
```
2025-10-03 00:00:00,000 - __main__ - INFO - Sensor service started (interval: 900s)
2025-10-03 00:00:00,050 - __main__ - INFO - Configuration loaded: device_id=opengardenlab-rpi001
```

**Successful Reading Cycle:**
```
2025-10-03 00:00:05,123 - __main__ - INFO - Sensor readings: moisture=45.2%, soil_temp=22.1Â°C, light=12000 lux, air_temp=23.5Â°C, humidity=55.2%
2025-10-03 00:00:06,234 - __main__ - INFO - Reading stored to database
```

**Error Handling:**
```
2025-10-03 06:15:05,456 - __main__ - WARNING - Failed to read BH1750: [Errno 121] Remote I/O error
2025-10-03 06:15:05,457 - __main__ - WARNING - Skipping reading due to sensor error
```

**Daily Volume:**
- 96 readings/day Ã— 2 log lines/reading = 192 log entries/day
- ~200 bytes/log Ã— 192 = ~38.4 KB/day
- Very sustainable for 10MB log files

### Testing
**Testing Standards for Story 1.8:**
- **Test Type:** Integration test with real log files and rotation behavior
- **Verification Steps:**
  1. âœ… Rotating file handler configured (10MB max, 5 backups)
  2. âœ… Logs directory created (`firmware/logs/`)
  3. âœ… Log file created on service startup
  4. âœ… INFO logs appear for: startup, sensor readings, database inserts
  5. âœ… WARNING logs appear for sensor read failures
  6. âœ… ERROR logs appear for critical failures (if simulated)
  7. âœ… Log format includes timestamp, logger name, level, message
  8. âœ… Dual handlers work (file + console output simultaneously)
  9. âœ… Real-time log monitoring via `tail -f` works
  10. âœ… Log rotation triggered when file exceeds 10MB (test script)
  11. âœ… Backup files created (`.log.1`, `.log.2`, etc.)
  12. âœ… Optional: LED blinks after successful reading (if wired)
- **Success Criteria:** Logs captured to file, rotation works, real-time monitoring via SSH, proper log levels used
- **No automated unit tests:** Manual integration test (pytest logging tests deferred to Story 1.10)
[Source: architecture/testing-strategy.md]

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-03 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*To be filled by QA agent*
